name: Release (macOS)

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-sign-notarize-release:
    name: Build â†’ Sign â†’ Notarize â†’ Release
    runs-on: macos-15
    timeout-minutes: 8
    environment: release
    env:
      APP_NAME: Annotate
      SCHEME: Annotate
      CONFIG: Release
      ARCHIVE_PATH: build/Annotate.xcarchive
      EXPORT_DIR: build/export
      EXPORT_PLIST: packaging/ExportOptions.plist

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode 16.2
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2'
          
      - name: Verify Xcode version
        run: xcodebuild -version

      - name: Resolve tag version
        id: version
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "semver=${TAG#v}" >> "$GITHUB_OUTPUT"
          # Generate build number from version (remove dots and dashes, keep alphanumeric)
          BUILD_NUMBER=$(echo "${TAG#v}" | sed 's/[.-]//g')
          echo "build_number=$BUILD_NUMBER" >> "$GITHUB_OUTPUT"

      - name: Install dependencies
        run: |
          # Install XcodeGen and pandoc for project generation and markdown processing
          brew install xcodegen pandoc

      - name: Generate Xcode project
        run: xcodegen generate

      - name: Inject TEAM_ID into ExportOptions
        run: |
          sed "s/__TEAM_ID__/${{ secrets.TEAM_ID }}/" "$EXPORT_PLIST" > "$EXPORT_PLIST.out"
          mv "$EXPORT_PLIST.out" "$EXPORT_PLIST"

      - name: Import Developer ID certificate
        uses: apple-actions/import-codesign-certs@v5
        with:
          p12-file-base64: ${{ secrets.MACOS_CERT_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERT_PASSWORD }}


      - name: Install xcpretty
        run: gem install xcpretty --no-document

      - name: Xcode archive (arm64, verbose, unsigned)
        timeout-minutes: 3
        run: |
          set -euxo pipefail
          mkdir -p build
          ENTRY="-project Annotate.xcodeproj"
          xcodebuild \
            $ENTRY \
            -scheme "$SCHEME" \
            -configuration "$CONFIG" \
            -archivePath "$ARCHIVE_PATH" \
            -destination "generic/platform=macOS" \
            ARCHS=arm64 \
            CODE_SIGNING_ALLOWED=NO \
            MARKETING_VERSION=${{ steps.version.outputs.semver }} \
            CURRENT_PROJECT_VERSION=${{ steps.version.outputs.build_number }} \
            clean archive | xcpretty && exit ${PIPESTATUS[0]}

      - name: Export signed app (Developer ID)
        timeout-minutes: 2
        run: |
          mkdir -p "$EXPORT_DIR"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_DIR" \
            -exportOptionsPlist "$EXPORT_PLIST" | xcpretty && exit ${PIPESTATUS[0]}

      - name: Re-sign with hardened runtime
        run: |
          codesign --force --sign "Developer ID Application" \
            -o runtime --timestamp \
            --entitlements "$APP_NAME/$APP_NAME.entitlements" \
            "$EXPORT_DIR/$APP_NAME.app"

      - name: Create ZIP for notarization
        run: |
          ZIP_NAME="$APP_NAME-${{ steps.version.outputs.semver }}.zip"
          ZIP_PATH="build/$ZIP_NAME"
          echo "ZIP_PATH=$ZIP_PATH" >> $GITHUB_ENV
          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV
          
          echo "ðŸ“¦ Creating ZIP archive: $ZIP_NAME"
          rm -f "$ZIP_PATH"
          # Use ditto to preserve extended attributes (including notarization ticket)
          ditto -c -k --keepParent "$EXPORT_DIR/$APP_NAME.app" "$ZIP_PATH"
          echo "âœ… ZIP created: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"

      - name: Notarize app bundle
        timeout-minutes: 5
        run: |
          echo "ðŸ“ Submitting ZIP archive for notarization..."
          xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "${{ secrets.NOTARIZE_APPLE_ID }}" \
            --password "${{ secrets.NOTARIZE_PASSWORD }}" \
            --team-id "${{ secrets.TEAM_ID }}" \
            --wait

      - name: Staple notarization to app bundle
        run: |
          echo "ðŸ“Ž Stapling notarization to .app bundle..."
          xcrun stapler staple "$EXPORT_DIR/$APP_NAME.app"
          xcrun stapler validate "$EXPORT_DIR/$APP_NAME.app"
          
          echo "Verifying app signature and entitlements..."
          codesign --verify --deep --strict --verbose=2 "$EXPORT_DIR/$APP_NAME.app"
          spctl -a -vvv --type exec "$EXPORT_DIR/$APP_NAME.app"

      - name: Update ZIP with stapled app
        run: |
          # Update ZIP with stapled notarization
          echo "ðŸ“¦ Updating ZIP with stapled notarization..."
          rm -f "$ZIP_PATH"
          # Use ditto to preserve extended attributes (including stapled notarization ticket)
          ditto -c -k --keepParent "$EXPORT_DIR/$APP_NAME.app" "$ZIP_PATH"
          echo "âœ… ZIP updated: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"

      - name: Package DMG from notarized app
        run: |
          chmod +x packaging/make_dmg.sh
          export MARKETING_VERSION="${{ steps.version.outputs.semver }}"
          DMG_PATH=$(./packaging/make_dmg.sh)
          echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV

      - name: Download Sparkle tools
        run: |
          SPARKLE_VERSION="2.8.0"
          SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          echo "Downloading Sparkle tools from: $SPARKLE_URL"
          curl -L "$SPARKLE_URL" | tar -xJ
          if [ ! -x "./bin/sign_update" ]; then
            echo "âŒ sign_update binary not found or not executable"
            exit 1
          fi
          echo "âœ… Sparkle tools downloaded and extracted"

      - name: Sign Sparkle update
        run: |
          # Verify ZIP file exists
          if [ ! -f "$ZIP_PATH" ]; then
            echo "âŒ ZIP file not found at: $ZIP_PATH"
            exit 1
          fi
          echo "âœ… ZIP file found: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"
          
          # Check if SPARKLE_PRIVATE_KEY secret exists
          if [ -z "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]; then
            echo "âŒ SPARKLE_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Create secure temporary file for private key
          PRIVATE_KEY_FILE=$(mktemp)
          trap "rm -f '$PRIVATE_KEY_FILE'" EXIT
          
          # Write private key to secure temp file
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" > "$PRIVATE_KEY_FILE"
          chmod 600 "$PRIVATE_KEY_FILE"
          
          # Verify private key file was created
          if [ ! -f "$PRIVATE_KEY_FILE" ] || [ ! -s "$PRIVATE_KEY_FILE" ]; then
            echo "âŒ Private key file creation failed"
            exit 1
          fi
          echo "âœ… Private key file created securely"
          
          # Verify sign_update binary
          if [ ! -x "./bin/sign_update" ]; then
            echo "âŒ sign_update binary not found or not executable"
            exit 1
          fi
          echo "âœ… sign_update binary found"
          
          # Sign the ZIP file with error handling
          echo "Signing ZIP file..."
          if SIGNATURE_OUTPUT=$(./bin/sign_update "$ZIP_PATH" -f "$PRIVATE_KEY_FILE" 2>&1); then
            # Extract just the signature value from the output
            # The output format is: sparkle:edSignature="SIGNATURE_VALUE" length="SIZE"
            SIGNATURE_VALUE=$(echo "$SIGNATURE_OUTPUT" | grep -o 'sparkle:edSignature="[^"]*"' | sed 's/sparkle:edSignature="//;s/"//')
            echo "SPARKLE_SIGNATURE=$SIGNATURE_VALUE" >> $GITHUB_ENV
            echo "âœ… Sparkle update signed successfully"
            echo "Signature: $SIGNATURE_VALUE"
            echo "Full output: $SIGNATURE_OUTPUT"
          else
            echo "âŒ Sparkle signing failed with error:"
            echo "$SIGNATURE_OUTPUT"
            exit 1
          fi
          
          # Private key cleanup handled by trap

      - name: Calculate ZIP file size
        run: |
          FILE_SIZE=$(stat -f%z "$ZIP_PATH")
          echo "ZIP_SIZE=$FILE_SIZE" >> $GITHUB_ENV
          echo "ZIP file size: $FILE_SIZE bytes"

      - name: Create GitHub Release & upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "Annotate ${{ github.ref_name }}"
          draft: false
          prerelease: false
          files: |
            ${{ env.DMG_PATH }}
            ${{ env.ZIP_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate and update appcast entry
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Use the same build number for Sparkle version consistency
          VERSION_NUMBER="${{ steps.version.outputs.semver }}"
          SPARKLE_VERSION="${{ steps.version.outputs.build_number }}"
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/$ZIP_NAME"
          
          # Use the isolated script to generate and insert the appcast entry
          chmod +x scripts/ci/generate_appcast_entry.sh
          ./scripts/ci/generate_appcast_entry.sh \
            "${{ steps.version.outputs.tag }}" \
            "$VERSION_NUMBER" \
            "$SPARKLE_VERSION" \
            "$SPARKLE_SIGNATURE" \
            "$ZIP_SIZE" \
            "$DOWNLOAD_URL"

      - name: Commit updated appcast
        run: |
          # Configure git if not already set
          git config user.name "github-actions[bot]" 2>/dev/null || true
          git config user.email "github-actions[bot]@users.noreply.github.com" 2>/dev/null || true
          
          git add appcast.xml
          if git diff --cached --quiet; then
            echo "No changes to appcast.xml"
          else
            git commit -m "chore: Update appcast.xml for release ${{ steps.version.outputs.tag }}"
            git push origin HEAD:auto-update
            echo "âœ… Committed updated appcast.xml"
          fi

