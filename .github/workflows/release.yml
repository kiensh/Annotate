name: Release (macOS)

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-sign-notarize-release:
    name: Build â†’ Sign â†’ Notarize â†’ Release
    runs-on: macos-15
    timeout-minutes: 8
    environment: release
    env:
      APP_NAME: Annotate
      SCHEME: Annotate
      CONFIG: Release
      ARCHIVE_PATH: build/Annotate.xcarchive
      EXPORT_DIR: build/export
      EXPORT_PLIST: packaging/ExportOptions.plist

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode 16.2
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2'
          
      - name: Verify Xcode version
        run: xcodebuild -version

      - name: Resolve tag version
        id: version
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "semver=${TAG#v}" >> "$GITHUB_OUTPUT"

      - name: Inject TEAM_ID into ExportOptions
        run: |
          sed "s/__TEAM_ID__/${{ secrets.TEAM_ID }}/" "$EXPORT_PLIST" > "$EXPORT_PLIST.out"
          mv "$EXPORT_PLIST.out" "$EXPORT_PLIST"

      - name: Import Developer ID certificate
        uses: apple-actions/import-codesign-certs@v5
        with:
          p12-file-base64: ${{ secrets.MACOS_CERT_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERT_PASSWORD }}


      - name: Install xcpretty
        run: gem install xcpretty --no-document

      - name: Xcode archive (arm64, verbose, unsigned)
        timeout-minutes: 3
        run: |
          set -euxo pipefail
          mkdir -p build
          ENTRY="-project Annotate.xcodeproj"
          xcodebuild \
            $ENTRY \
            -scheme "$SCHEME" \
            -configuration "$CONFIG" \
            -archivePath "$ARCHIVE_PATH" \
            -destination "generic/platform=macOS" \
            ARCHS=arm64 \
            CODE_SIGNING_ALLOWED=NO \
            MARKETING_VERSION=${{ steps.version.outputs.semver }} \
            clean archive | xcpretty && exit ${PIPESTATUS[0]}

      - name: Export signed app (Developer ID)
        timeout-minutes: 2
        run: |
          mkdir -p "$EXPORT_DIR"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_DIR" \
            -exportOptionsPlist "$EXPORT_PLIST" | xcpretty && exit ${PIPESTATUS[0]}

      - name: Re-sign with hardened runtime
        run: |
          codesign --force --sign "Developer ID Application" \
            -o runtime --timestamp \
            --entitlements "$APP_NAME/$APP_NAME.entitlements" \
            "$EXPORT_DIR/$APP_NAME.app"

      - name: Create ZIP for notarization
        run: |
          ZIP_NAME="$APP_NAME-${{ steps.version.outputs.semver }}.zip"
          ZIP_PATH="build/$ZIP_NAME"
          echo "ZIP_PATH=$ZIP_PATH" >> $GITHUB_ENV
          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV
          
          echo "ðŸ“¦ Creating ZIP archive: $ZIP_NAME"
          rm -f "$ZIP_PATH"
          (cd "$EXPORT_DIR" && zip -r "../$ZIP_NAME" "$APP_NAME.app")
          echo "âœ… ZIP created: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"

      - name: Notarize app bundle
        timeout-minutes: 5
        run: |
          echo "ðŸ“ Submitting ZIP archive for notarization..."
          xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "${{ secrets.NOTARIZE_APPLE_ID }}" \
            --password "${{ secrets.NOTARIZE_PASSWORD }}" \
            --team-id "${{ secrets.TEAM_ID }}" \
            --wait

      - name: Staple notarization to app bundle
        run: |
          echo "ðŸ“Ž Stapling notarization to .app bundle..."
          xcrun stapler staple "$EXPORT_DIR/$APP_NAME.app"
          xcrun stapler validate "$EXPORT_DIR/$APP_NAME.app"
          
          echo "Verifying app signature and entitlements..."
          codesign --verify --deep --strict --verbose=2 "$EXPORT_DIR/$APP_NAME.app"
          spctl -a -vvv --type exec "$EXPORT_DIR/$APP_NAME.app"

      - name: Update ZIP with stapled app
        run: |
          # Update ZIP with stapled notarization
          echo "ðŸ“¦ Updating ZIP with stapled notarization..."
          rm -f "$ZIP_PATH"
          (cd "$EXPORT_DIR" && zip -r "../$ZIP_NAME" "$APP_NAME.app")
          echo "âœ… ZIP updated: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"

      - name: Package DMG from notarized app
        run: |
          chmod +x packaging/make_dmg.sh
          MARKETING_VERSION="${{ steps.version.outputs.semver }}" DMG_PATH=$(./packaging/make_dmg.sh)
          echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV

      - name: Download Sparkle tools
        run: |
          SPARKLE_VERSION="2.8.0"
          SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          echo "Downloading Sparkle tools from: $SPARKLE_URL"
          curl -L "$SPARKLE_URL" | tar -xJ
          if [ ! -x "./bin/sign_update" ]; then
            echo "âŒ sign_update binary not found or not executable"
            exit 1
          fi
          echo "âœ… Sparkle tools downloaded and extracted"

      - name: Sign Sparkle update
        run: |
          # Verify ZIP file exists
          if [ ! -f "$ZIP_PATH" ]; then
            echo "âŒ ZIP file not found at: $ZIP_PATH"
            exit 1
          fi
          echo "âœ… ZIP file found: $ZIP_PATH ($(stat -f%z "$ZIP_PATH") bytes)"
          
          # Check if SPARKLE_PRIVATE_KEY secret exists
          if [ -z "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]; then
            echo "âŒ SPARKLE_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Create secure temporary file for private key
          PRIVATE_KEY_FILE=$(mktemp)
          trap "rm -f '$PRIVATE_KEY_FILE'" EXIT
          
          # Write private key to secure temp file
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" > "$PRIVATE_KEY_FILE"
          chmod 600 "$PRIVATE_KEY_FILE"
          
          # Verify private key file was created
          if [ ! -f "$PRIVATE_KEY_FILE" ] || [ ! -s "$PRIVATE_KEY_FILE" ]; then
            echo "âŒ Private key file creation failed"
            exit 1
          fi
          echo "âœ… Private key file created securely"
          
          # Verify sign_update binary
          if [ ! -x "./bin/sign_update" ]; then
            echo "âŒ sign_update binary not found or not executable"
            exit 1
          fi
          echo "âœ… sign_update binary found"
          
          # Sign the ZIP file with error handling
          echo "Signing ZIP file..."
          if SIGNATURE=$(./bin/sign_update "$ZIP_PATH" -f "$PRIVATE_KEY_FILE" 2>&1); then
            echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
            echo "âœ… Sparkle update signed successfully"
            echo "Signature: $SIGNATURE"
          else
            echo "âŒ Sparkle signing failed with error:"
            echo "$SIGNATURE"
            exit 1
          fi
          
          # Private key cleanup handled by trap

      - name: Calculate ZIP file size
        run: |
          FILE_SIZE=$(stat -f%z "$ZIP_PATH")
          echo "ZIP_SIZE=$FILE_SIZE" >> $GITHUB_ENV
          echo "ZIP file size: $FILE_SIZE bytes"

      - name: Generate appcast entry
        run: |
          PUB_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/$ZIP_NAME"
          
          # Extract current version number for sparkle:version (remove dots)
          VERSION_NUMBER="${{ steps.version.outputs.semver }}"
          SPARKLE_VERSION=$(echo "$VERSION_NUMBER" | tr -d '.')
          
          
          # Generate new appcast entry
          cat > new_entry.xml << EOF
          <item>
              <title>Version ${{ steps.version.outputs.tag }}</title>
              <link>https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}</link>
              <description><![CDATA[
          ## ðŸš€ Annotate ${{ steps.version.outputs.tag }}
          
          See the [full changelog](https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}) for details.
              ]]></description>
              <pubDate>$PUB_DATE</pubDate>
              <enclosure url="$DOWNLOAD_URL"
                         sparkle:version="$SPARKLE_VERSION"
                         sparkle:shortVersionString="$VERSION_NUMBER"
                         sparkle:edSignature="$SPARKLE_SIGNATURE"
                         length="$ZIP_SIZE"
                         type="application/octet-stream" />
          </item>
          EOF
          
          echo "âœ… Generated appcast entry for version ${{ steps.version.outputs.tag }}"

      - name: Update appcast.xml
        run: |
          # Insert new entry after the opening <channel> tag
          # This places the newest version at the top
          sed -i.tmp '/<channel>/r new_entry.xml' appcast.xml
          rm appcast.xml.tmp new_entry.xml
          
          echo "âœ… Updated appcast.xml with new entry"

      - name: Commit updated appcast
        run: |
          # Configure git if not already set
          git config user.name "github-actions[bot]" 2>/dev/null || true
          git config user.email "github-actions[bot]@users.noreply.github.com" 2>/dev/null || true
          
          git add appcast.xml
          if git diff --cached --quiet; then
            echo "No changes to appcast.xml"
          else
            git commit -m "chore: Update appcast.xml for release ${{ steps.version.outputs.tag }}"
            git push origin HEAD:auto-update
            echo "âœ… Committed updated appcast.xml"
          fi

      - name: Create GitHub Release & upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "Annotate ${{ github.ref_name }}"
          draft: false
          prerelease: false
          files: |
            ${{ env.DMG_PATH }}
            ${{ env.ZIP_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

